<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link rel="icon" href="./images/logo.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
    <link rel="stylesheet" href="./style.css">
    <link rel="stylesheet" href="https://pro.fontawesome.com/releases/v5.10.0/css/all.css"
        integrity="sha384-AYmEC3Yw5cVb3ZcuHtOA93w35dYTsvhLPVnYs9eStHfGJvOvKxVfELGroGkvsg+p" crossorigin="anonymous" />
    <link rel="stylesheet" href="./docs.css">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <title>CPU Scheduling Simulator</title>
</head>

<body>
    <section class="sub-header">
        <nav>
            <a href="index.html"><img
                src="./images/cube.png"
                style="width: 50px; height: 45px"
                class="logo"
              /></a>
            <div class="nav-links" id="navLinks">
                <i class="fas fa-window-close" onclick="hideMenu()"></i>
                <ul>
                    <li><a href="index.html">HOME</a></li>
                    <li><a href="docs.html">DOCS</a></li>
                    <!-- <li><a href="blog.html">BLOG</a></li> -->
                    <li><a href="./backend/ganttcharts.html">SIMULATOR</a></li>
                    <li><a href="about.html">ABOUT</a></li>

                </ul>
            </div>
            <i class="fas fa-bars" onclick="showMenu()"></i>
        </nav>

        <h1>Documentation</h1>

    </section>



    <section class="container_docs" >
        <h1>What is CPU Scheduling?</h1>
        <p>CPU Scheduling is a process of determining which process will own CPU
            for execution while another process is on hold. The main task of CPU
            scheduling is to make sure that whenever the CPU remains idle, the OS
            at least select one of the processes available in the ready queue for
            execution. The selection process will be carried out by the CPU
            scheduler. It selects one of the processes in memory that are ready
            for execution.
        </p>
    </section>

    <section class="container_docs" data-aos="zoom-in-up">
        <h1>Why CPU Scheduling?</h1>
        <p>A typical process involves both I/O time and CPU time. In a uni
          programming system like MS-DOS, time spent waiting for I/O is wasted
          and CPU is free during this time. In multi programming systems, one
          process can use CPU while another is waiting for I/O. This is possible
          only with process scheduling.<br><br>
            <strong>Objectives of Process Scheduling Algorithm:</strong>
            <li>Max CPU utilization [Keep CPU as busy as possible]</li>
            <li>Fair allocation of CPU.</li>
            <li>Max throughput [Number of processes that complete their execution per time unit]</li>
            <li>Min turnaround time [Time taken by a process to finish execution]</li>
            <li>Min waiting time [Time a process waits in ready queue]</li>
            <li>Min response time [Time when a process produces first response]</li>
        </p>
    </section>

    <section class="container_docs special" data-aos="zoom-in-up">
        <h1>Important CPU Scheduling Terminologies</h1>
        <!-- <p>A typical process involves both I/O time and CPU time. In a uni programming system like MS-DOS, time spent waiting for I/O is wasted and CPU is free during this time. In multi programming systems, one process can use CPU while another is waiting for I/O. This is possible only with process scheduling.<br><br> -->
        <li><strong>Burst Time/Execution Time:</strong> It is a time required by the process to complete execution. It
            is also called running time.</li>
        <li><strong>Arrival Time:</strong> when a process enters in a ready state</li>
        <li><strong>Finish Time:</strong> when process complete and exit from a system</li>
        <li><strong>Multiprogramming:</strong> A number of programs which can be present in memory at the same time.
        </li>
        <li><strong>Jobs:</strong> It is a type of program without any kind of user interaction.</li>
        <li><strong>User:</strong> It is a kind of program having user interaction.</li>
        <li><strong>Process:</strong> It is the reference that is used for both job and user.</li>
        <li><strong>CPU/IO burst cycle:</strong> Characterizes process execution, which alternates between CPU and I/O
            activity. CPU times are shorter than the time of I/O.</li>

        </p>
    </section>











    <section class="container_docs" data-aos="zoom-in-up">
        <h1>Types of CPU Scheduling</h1>
        <p>There is mainly two major types of CPU Scheduling which is listed
            below. There is sub-types of this algorithm also. We have discussed
            all algorithm in details below: </p>
        <li>Preemptive Algorithm</li>
        <li>Non Preemptive Algorithm</li>
        <br>

        <p><strong class="bold" style="font-size: 24px;">Preemptive Scheduling</strong><br><br>
            In Preemptive Scheduling, the tasks are mostly assigned with their
          priorities. Sometimes it is important to run a task with a higher
          priority before another lower priority task, even if the lower
          priority task is still running. The lower priority task holds for some
          time and resumes when the higher priority task finishes its execution.<br><br>
            <br>
            <strong class="bold" style="font-size: 24px;">Non-Preemptive Scheduling</strong><br><br>
            In this type of scheduling method, the CPU has been allocated to a
            specific process. The process that keeps the CPU busy will release the
            CPU either by switching context or terminating. It is the only method
            that can be used for various hardware platforms. That’s because it
            doesn’t need special hardware (for example, a timer) like preemptive
            scheduling.
        </p>

        

    </section>


    <section class="container_docs" data-aos="zoom-in-up">
        <h1>Types of CPU Scheduling Algorithm</h1>
        <p>There are five types of process scheduling algorithm:</p>

        <li>First Come First Serve (FCFS) Scheduling</li>
        <li>Shortest-Job-First (SJF) Scheduling</li>
        <li>Shortest Remaining Time First (SRTF) Scheduling</li>
        <li>Priority Scheduling</li>
        <li>Round Robin Scheduling</li>
        <br>
    </section>



    <section class="container_docs" data-aos="zoom-in-up">
        <h1>1) First Come First Serve Scheduling</h1>
        <p>First Come First Serve (FCFS) is a scheduling which is considered to
            be the easiest and simplest of all operating system scheduling
            algorithms. First come first serve scheduling algorithm states that
            the process that requests the CPU first is allocated the CPU first and
            is implemented by using FIFO queue.</p>

        <h4>
            <li>Characteristics:</li>
        </h4>
        <p>1. FCFS supports non-preemptive and preemptive CPU scheduling
            algorithms.
            <br />
            2. Tasks are always executed on a First-come, First-serve concept.
            <br />
            3. FCFS is easy to implement and use.
            <br />
            4. This algorithm is not much efficient in performance, and the wait
            time is quite high.
            <br />

            <h4>
                <li>Advantages:</li>
            </h4>
            <p>1. Easy to implement <br />
                2. First come, first serve method
                <br />
            </p>
            <h4>
                <li>Disadvantages:</li>
              </h4>
              <p>
                1. FCFS suffers from Convoy effect.
                <br />
                2. The average waiting time is much higher than the other
                algorithms.
                <br />
                3. FCFS is very simple and easy to implement and hence not much
                efficient.
                <br />
              </p>
            <button class="btn_1" onclick="gotoSimulator();">Go to Simulator</button>
        </p>
        
    </section>

    <section class="container_docs" data-aos="zoom-in-up">
        <h1>2) Shortest Job First Scheduling</h1>
        <p>Shortest Job First (SJF) is a scheduling process that selects the
            waiting process with the smallest execution time to execute next. This
            scheduling method may or may not be preemptive. Significantly reduces
            the average waiting time for other processes waiting to be executed.
            The full form of SJF is Shortest Job First.<br></p>

        <h4>
            <li>Characteristics:</li>
        </h4>
        <p>
            1. Shortest Job first has the advantage of having a minimum average
            waiting time among all operating system scheduling algorithms.
            <br />
            2. It is associated with each task as a unit of time to complete.
            <br />
            3. It may cause starvation if shorter processes keep coming. <br />
            4. This problem can be solved using the concept of ageing.
            <br />
          </p>
        <h4>
            <li>Advantages:</li>
        </h4>
        <p>
            1. As SJF reduces the average waiting time thus, it is better than
            the first come first serve scheduling algorithm.
            <br />
            2. It is generally used for long term scheduling
            <br />
          </p>

        <h4>
            <li>Disadvantages:</li>
        </h4>
        <p>
            1. One of the demerit SJF has is starvation.
            <br />
            2. Many times it becomes complicated to predict the length of the
            upcoming CPU request
            <br />
          </p>
            <button class="btn_1" onclick="gotoSimulator();">Go to Simulator</button>
        <br>
    </section>

    <section class="container_docs" data-aos="zoom-in-up">
        <h1>3) Shortest Remaining Time First Scheduling</h1>
        <p>Shortest Remaining Time First (SRTF) is the preemptive version of the
            Shortest Job First which we have discussed earlier where the processor
            is allocated to the job closest to completion. In SRTF the process
            with the smallest amount of time remaining until completion is
            selected to execute.<br><br>

        </p>
        <h4>
            <li>Characteristics:</li>
        </h4>
        <p>1. SRTF algorithm makes the processing of the jobs faster than SJF
            algorithm, given it’s overhead charges are not counted.
            <br />
            2. The context switch is done a lot more times in SRTF than in SJF
            and consumes the CPU’s valuable time for processing. This adds up to
            its processing time and diminishes its advantage of fast processing.<br>
        </p>
        <h4>
            <li>Advantages:</li>
        </h4>
        <p>1. In SRTF the short processes are handled very fast.
            <br />
            2. The system also requires very little overhead since it only makes
            a decision when a process completes or a new process is added.
            <br /><br>
        </p>

        <h4>
            <li>Disadvantages:</li>
        </h4>
        <p>1. Like the shortest job first, it also has the potential for
            process starvation.
            <br />
            2. Long processes may be held off indefinitely if short processes
            are continually added.
            <br />
        </p>
            <button class="btn_1" onclick="gotoSimulator();">Go to Simulator</button>
        <br>
    </section>

    <section class="container_docs" data-aos="zoom-in-up">
        <h1>4) Priority Scheduling</h1>
        <p>Preemptive Priority CPU Scheduling Algorithm is a pre-emptive method
            of CPU scheduling algorithm that works based on the priority of a
            process. In this algorithm, the editor sets the functions to be as
            important, meaning that the most important process must be done first.
            <br><br>
            In the case of any conflict, that is, where there are more than one
          processor with equal value, then the most important CPU planning
          algorithm works on the basis of the FCFS (First Come First Serve)
          algorithm.
        </p>

        <h4>
            <li>Characteristics:</li>
        </h4>
        <p>1. Schedules tasks based on priority.
            <br />
            2. When the higher priority work arrives while a task with less
            priority is executed, the higher priority work takes the place of
            the less priority one. <br />
            3. The latter is suspended until the execution is complete.
            <br />
            4. Lower is the number assigned, higher is the priority level of a
            process.
            <br /></p>
        <h4>
            <li>Advantages:</li>
        </h4>
        <p>1. The average waiting time is less than FCFS.
            <br />
            2. Less complex.
            <br />
        </p>

        <h4>
            <li>Disadvantages:</li>
        </h4>
        <p>1. One of the most common demerits of the Preemptive priority CPU
            scheduling algorithm is the Starvation Problem.
            <br />
            2. This is the problem in which a process has to wait for a longer
            amount of time to get scheduled into the CPU. This condition is
            called the starvation problem.
            <br />
        </p>
        <button class="btn_1" onclick="gotoSimulator();">Go to Simulator</button>
        <br>
    </section>

    <section class="container_docs" data-aos="zoom-in-up">
        <h1>5) Round Robin Scheduling</h1>
        <p>Round Robin (RR) is a CPU scheduling algorithm where each process is
            cyclically assigned a fixed time slot. It is the preemptive version of
            First come First Serve CPU Scheduling algorithm. Round Robin CPU
            Algorithm generally focuses on Time Sharing technique.<br></p>

        <h4>
            <li>Characteristics:</li>
        </h4>
        <p>1. It’s simple, easy to use, and starvation-free as all processes
            get the balanced CPU allocation.
            <br />
            2. One of the most widely used methods in CPU scheduling as a core.
            <br />
            3. It is considered preemptive as the processes are given to the CPU
            for a very limited time.
            <br />
        </p>
        <h4>
            <li>Advantages:</li>
        </h4>
        <p>1. Round robin seems to be fair as every process gets an equal share
            of CPU.
            <br />
            2. The newly created process is added to the end of the ready queue.
            <br />
            3. RR is cyclic in nature, so there is no starvation.
            <br />
        </p>

        <h4>
            <li>Disadvantages</li>
        </h4>
        <p>1. Setting the quantum too short increases the overhead and lowers
            the CPU efficiency, but setting it too long may cause a poor
            response to short processes.
            <br />
            2. The average waiting time under the RR policy is often long.
            <br />
            3. If time quantum is very high then RR degrades to FCFS.
            <br />
        </p>

            <button class="btn_1" onclick="gotoSimulator();">Go to Simulator</button>
        <br>
    </section>

    <!-- <section class="container_docs" data-aos="zoom-in-up">
        <h1>6) Multiple-Level Queues Scheduling</h1>
        <p>This algorithm separates the ready queue into various separate queues. In this method, processes are assigned
            to a queue based on a specific property of the process, like the process priority, size of the memory,
            etc.<br><br>

            However, this is not an independent scheduling OS algorithm as it needs to use other types of algorithms in
            order to schedule the jobs.<br><br></p>

        <h4>
            <li>Advantages</li>
        </h4>
        <p>1. Application of separate scheduling for various kind of processes is possible
            .<br></p>

        <h4>
            <li>Disadvantages</li>
        </h4>
        <p>1. The lowest level process faces starvation problem.<br></p>

        <button class="btn_1" onclick="gotoSimulator();">Go to Simulator</button>
        <br>
    </section> -->

     
    <section class="footer">
        <!-- <h4>About Us</h4>
        <p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Soluta pariatur eveniet eaque provident error velit totam quos. Corrupti sunt omnis<br>  eligendi ut enim, sed magnamquo laboriosam, aspernatur nulla ipsum commodi itaque accusantium sapiente!</p> -->

        <div class="icons">
            <a href="https://www.facebook.com"><i  class="fab fa-facebook"></i></a>
            <a href="https://www.instagram.com/"><i class="fab fa-instagram"></i></a>
            <a href="https://github.com/"><i class="fab fa-brands fa-github"></i></a>
            <a href="https://www.linkedin.com/ "><i class="fab fa-linkedin"></i></a>
        </div>
            
        <p>Made With <i class="far fa-heart"></i> by Gurusharan & Satyanarayan.</p>
        <p> <i class="fa fa-copyright"></i> Copyright 2022 || All rights reserved</p>
    </section>

    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.10.2/dist/umd/popper.min.js"
        integrity="sha384-7+zCNj/IqJ95wo16oMtfsKbZ9ccEh31eOz1HGyDuCQ6wgnyJNSYdrPa03rtR1zdB"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.min.js"
        integrity="sha384-QJHtvGhmr9XOIpI6YVutG+2QOK9T+ZnN4kzFN1RtK3zEFEIsxhlmWl5/YESvpZ13"
        crossorigin="anonymous"></script>

    <script>
        var navLinks = document.getElementById("navLinks");
        function showMenu() {
            navLinks.style.right = "0";
        }

        function hideMenu() {
            navLinks.style.right = "-200px";
        }

        function gotoSimulator(){
            location.href = ("./backend/ganttcharts.html");
        }
    </script>


    <!-- For the animation -->
    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
    <script>
      AOS.init({
        offset: 200, // offset (in px) from the original trigger point
        duration: 800
      });
    </script>
</body>

</html>
